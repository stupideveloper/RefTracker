// src/router.ts
import u from "regexparam";
import {ServerRequest as R} from "worktop/request";
import {ServerResponse as m} from "worktop/response";

// src/internal/constants.ts
var f = {
  "400": "Bad Request",
  "401": "Unauthorized",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "413": "Payload Too Large",
  "422": "Unprocessable Entity",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout"
};

// src/router.ts
function y(t) {
  return (s) => s.respondWith(t(s));
}
function w(t) {
  addEventListener("fetch", y(t));
}
var l = !1;
function x(...t) {
  return async function(s, o) {
    let n, r, e = t.length;
    for (n of t)
      if (r = await c(n, --e <= 0 && !l, s, o))
        return r;
  };
}
async function c(t, s, o, n, ...r) {
  let e = await t(o, n, ...r);
  if (e instanceof Response)
    return e;
  if (s || n.finished)
    return new Response(n.body, n);
}
function E() {
  let t, s = {};
  return t = {
    add(o, n, r) {
      let e = s[o];
      if (e === void 0 && (e = s[o] = {
        __d: new Map(),
        __s: {}
      }), n instanceof RegExp)
        e.__d.set(n, {keys: [], handler: r});
      else if (/[:|*]/.test(n)) {
        let {keys: a, pattern: i} = u(n);
        e.__d.set(i, {keys: a, handler: r});
      } else
        e.__s[n] = {keys: [], handler: r};
    },
    find(o, n) {
      let r = {}, e, a, i, d, p;
      if (a = s[o]) {
        if (e = a.__s[n])
          return {params: r, handler: e.handler};
        for ([i, d] of a.__d)
          if (p = i.exec(n), p !== null) {
            if (p.groups !== void 0)
              for (e in p.groups)
                r[e] = p.groups[e];
            else if (d.keys.length > 0)
              for (e = 0; e < d.keys.length; )
                r[d.keys[e++]] = p[e];
            return {params: r, handler: d.handler};
          }
      }
    },
    onerror(o, n, r, e) {
      let a = f[r = r || 500], i = e && e.message || a || String(r);
      return new Response(i, {status: r, statusText: a});
    },
    async run(o) {
      let n, r = new R(o), e = new m(r.method);
      if (l = !!t.prepare) {
        if (n = await c(t.prepare, !1, r, e), n)
          return n;
        l = !1;
      }
      return n = t.find(r.method, r.path), n ? (r.params = n.params, c(n.handler, !0, r, e).catch((a) => c(t.onerror, !0, r, e, 500, a))) : c(t.onerror, !0, r, e, 404);
    }
  };
}
export {
  E as Router,
  f as STATUS_CODES,
  x as compose,
  w as listen,
  y as reply
};
